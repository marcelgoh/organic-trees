%!PS
%%BoundingBox: [0 0 1 1]
% Generate and illustrate a random BST
% Written by Marcel Goh on 3 April 2020

0.5 setlinewidth

%%% CONSTANTS/PARAMETERS
/NUM_NODES 10 def
/RAND 34243 def      % seed for RNG
/U { 0.5 mul } def     % unit of measure

% RNG helpers (Knuth Vol.2, p. 185)
/MM 2147483647 def
/AA 48271 def
/QQ 44488 def
/RR 3399 def
% updates the value of RAND
/NEXT_RAND {
    % RAND = AA*(RAND % QQ) - RR*(RAND / QQ)
    /RAND AA RAND QQ mod mul RR RAND QQ idiv mul sub def
    RAND 0 lt {
        /RAND RAND MM add def
    } if
} def
50 { NEXT_RAND } repeat

% push a new random number from [0,1) onto the stack
/UNI {RAND MM div NEXT_RAND} def

% fields for each node in BST
/KEY NUM_NODES array def
/PARENT NUM_NODES array def
/LEFT NUM_NODES array def
/RIGHT NUM_NODES array def
/HS NUM_NODES array def   % Horton-Strahler

% initialise root
KEY 0 UNI put    % set KEY[root] <- new random number
PARENT 0 -1 put  % PARENT[root] <- nil (-1 indicates nil)
LEFT 0 -1 put    % ditto for LEFT, RIGHT
RIGHT 0 -1 put

% Test
/BOOL NUM_NODES array def
/DEBUG -3 def
% End Test

% insert nodes with random keys into BST
1 1 NUM_NODES 1 sub {
    /i exch def
    /new_key UNI def
    KEY i new_key put  % create new leaf node
    LEFT i -1 put
    RIGHT i -1 put

    /curr 0 def  % travelling pointer starts at root
    /next 0 def
    % descend the tree
    {
        /go_left new_key KEY curr get lt def
        go_left {
            /next LEFT curr get def
        } {
            /next RIGHT curr get def
        } ifelse
        next -1 eq {
            % new leaf inserts here
            go_left {
                LEFT curr i put
            } {
                RIGHT curr i put
            } ifelse
            PARENT i curr put
            exit
        } if
        /curr next def
    } loop
} for

% calculate Horton-Strahler number (Knuth Vol. 4, p. 485)
/STACK NUM_NODES array def
STACK 0 0 put
/STACK_SIZE 1 def
{   % postorder traversal and calculation
    % we use only one stack; if the number N on the stack is greater
    % than NUM_NODES, it indicates that node N is to be visited
    /STACK_SIZE STACK_SIZE 1 sub def  % pop off stack
    /curr STACK STACK_SIZE get def

    curr NUM_NODES lt {
        /rchild RIGHT curr get def
        /lchild LEFT curr get def
        % push node again; next time it will be visited
        STACK STACK_SIZE curr NUM_NODES add put
        /STACK_SIZE STACK_SIZE 1 add def
        % push children: they will be dealt with first
        rchild -1 ne {
            STACK STACK_SIZE rchild put
            /STACK_SIZE STACK_SIZE 1 add def
        } if
        lchild -1 ne {
            STACK STACK_SIZE lchild put
            /STACK_SIZE STACK_SIZE 1 add def
        } if
    } {
        % visit node
        /curr curr NUM_NODES sub def
        /rchild RIGHT curr get def
        /lchild LEFT curr get def
        /vleft lchild -1 eq { 0 } { HS lchild get } ifelse def
        /vright rchild -1 eq { 0 } { HS rchild get } ifelse def
        /m vleft vright gt { vleft } { vright } ifelse def
        /b vleft vright eq { 1 } { 0 } ifelse def
        HS curr m b add put
    } ifelse
    STACK_SIZE 0 eq { exit } if
} loop

% k V gets HS number if internal node; else returns 0
/V { /k exch def k -1 eq { 0 } { HS k get } ifelse } def

% v RECT draws the correct shape for the HS number v
/RECT {
    /v exch def
    v 0 eq {
        newpath
            0 0 moveto
            3 U 18 U rlineto
            6 U neg 0 rlineto
            0 0 lineto
            gsave
                1 1 1 setcolor fill
            grestore
        stroke
    } {
        /w 3 v add U def
        /h 18 v mul U def
        newpath
            w 2 div neg 0 moveto
            w 0 rlineto
            0 h rlineto
            w neg 0 rlineto
            0 h neg rlineto
            gsave
                1 1 1 setcolor fill
            grestore
        stroke
    } ifelse
} def

gsave
    300 100 translate
    4 RECT
grestore
gsave
    300 100 18 4 mul U add translate
    30 rotate
    3 RECT
    -60 rotate
    0 RECT
grestore

% x y v theta DRAW_NODE puts node with (x,y) at bottom middle
/DRAW_NODE {
    2
} def

% FOR TESTING
/DEBUG_PRINT {
    % arr label x y PRINT_ARR prints an array for debug
    /Courier findfont 10 scalefont setfont
    /PRINT_ARR {
        moveto show (  ) show
        /arr exch def
        /len arr length def
        /s 20 string def
        0 1 len 1 sub {
            /i exch def
            arr i get s cvs show
            ( ) show
        } for
    } def

    50 580 moveto (DEBUG: ) show DEBUG 8 string cvs show
    STACK (STACK:) 50 600 PRINT_ARR
    HS (HS:) 50 620 PRINT_ARR
    PARENT (PARENT:) 50 640 PRINT_ARR
    RIGHT (RIGHT:) 50 660 PRINT_ARR
    LEFT (LEFT:) 50 680 PRINT_ARR
    KEY (KEY:) 50 700 PRINT_ARR
} def

DEBUG_PRINT

showpage
